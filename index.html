<!DOCTYPE html>
<html>
<head>
    <title>Canvas Fingerprint Generator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        button { padding: 12px 24px; font-size: 16px; margin: 10px; cursor: pointer; }
        pre { background: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
        .result { margin-top: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Canvas Fingerprint Generator</h1>
        <p>Click the button to generate your hardware fingerprint</p>
        
        <button onclick="generateAndDownload()">Generate & Download Fingerprint</button>
        <button onclick="generateAndShow()">Generate & Show Only</button>
        
        <div class="result" id="result"></div>
    </div>

    <script>
        function generateCanvasFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = 240;
            canvas.height = 120;
            
            // ðŸŽ¯ HARDWARE-SPECIFIC RENDERING
            
            // Background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Text rendering (font smoothing differences)
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillStyle = '#f60';
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = '#069';
            ctx.fillText('Hardware ID: @#$%', 2, 15);
            ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
            ctx.fillText('Hardware ID: @#$%', 4, 17);
            
            // Complex shapes (GPU rendering patterns)
            ctx.strokeStyle = 'rgb(200, 0, 0)';
            ctx.beginPath();
            ctx.moveTo(10, 40);
            ctx.lineTo(140, 40);
            ctx.lineTo(10, 80);
            ctx.lineTo(140, 80);
            ctx.lineTo(10, 120);
            ctx.lineTo(140, 120);
            ctx.stroke();
            
            // Gradients (color rendering differences)
            const gradient = ctx.createLinearGradient(150, 40, 230, 100);
            gradient.addColorStop(0, '#ff0000');
            gradient.addColorStop(0.5, '#00ff00');
            gradient.addColorStop(1, '#0000ff');
            ctx.fillStyle = gradient;
            ctx.fillRect(150, 40, 80, 60);
            
            // Complex curves (anti-aliasing differences)
            ctx.strokeStyle = '#000';
            ctx.beginPath();
            ctx.arc(50, 100, 30, 0, Math.PI * 2, true);
            ctx.stroke();
            
            // Get image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixelData = imageData.data;
            
            // ðŸŽ¯ EXTRACT HARDWARE PATTERNS
            const fingerprint = {
                imageHash: calculateImageHash(pixelData),
                colorDistribution: calculateColorDistribution(pixelData),
                gradientPatterns: analyzeGradientPatterns(pixelData, canvas.width),
                edgeDetection: detectEdgePatterns(pixelData, canvas.width),
                noisePattern: analyzeNoisePattern(pixelData),
                entropy: calculateEntropy(pixelData),
                contrast: calculateContrast(pixelData),
                meanBrightness: calculateMeanBrightness(pixelData),
                renderingArtifacts: detectRenderingArtifacts(pixelData)
            };
            
            return fingerprint;
        }

        function calculateImageHash(pixelData) {
            let hash = 0;
            for (let i = 0; i < pixelData.length; i += 4) {
                hash = ((hash << 5) - hash) + pixelData[i];
                hash |= 0; // Convert to 32bit integer
            }
            return hash;
        }

        function calculateColorDistribution(pixelData) {
            const distribution = { r: 0, g: 0, b: 0 };
            for (let i = 0; i < pixelData.length; i += 4) {
                distribution.r += pixelData[i];
                distribution.g += pixelData[i + 1];
                distribution.b += pixelData[i + 2];
            }
            const total = pixelData.length / 4;
            return {
                r: distribution.r / total,
                g: distribution.g / total,
                b: distribution.b / total
            };
        }

        function analyzeGradientPatterns(pixelData, width) {
            const patterns = [];
            for (let y = 0; y < 120; y += 10) {
                let rowPattern = 0;
                for (let x = 0; x < 240; x += 10) {
                    const idx = (y * width + x) * 4;
                    const brightness = (pixelData[idx] + pixelData[idx + 1] + pixelData[idx + 2]) / 3;
                    rowPattern = (rowPattern << 2) | (brightness > 128 ? 1 : 0);
                }
                patterns.push(rowPattern);
            }
            return patterns;
        }

        function detectEdgePatterns(pixelData, width) {
            let edges = 0;
            for (let y = 1; y < 119; y++) {
                for (let x = 1; x < 239; x++) {
                    const idx = (y * width + x) * 4;
                    const current = (pixelData[idx] + pixelData[idx + 1] + pixelData[idx + 2]) / 3;
                    const right = (pixelData[idx + 4] + pixelData[idx + 5] + pixelData[idx + 6]) / 3;
                    const bottom = (pixelData[idx + width * 4] + pixelData[idx + width * 4 + 1] + pixelData[idx + width * 4 + 2]) / 3;
                    
                    const edgeStrength = Math.abs(current - right) + Math.abs(current - bottom);
                    if (edgeStrength > 50) edges++;
                }
            }
            return edges;
        }

        function analyzeNoisePattern(pixelData) {
            let noise = 0;
            for (let i = 4; i < pixelData.length; i += 4) {
                const prev = (pixelData[i - 4] + pixelData[i - 3] + pixelData[i - 2]) / 3;
                const curr = (pixelData[i] + pixelData[i + 1] + pixelData[i + 2]) / 3;
                noise += Math.abs(curr - prev);
            }
            return noise / (pixelData.length / 4);
        }

        function calculateEntropy(pixelData) {
            const brightnessCounts = Array(256).fill(0);
            for (let i = 0; i < pixelData.length; i += 4) {
                const brightness = Math.floor((pixelData[i] + pixelData[i + 1] + pixelData[i + 2]) / 3);
                brightnessCounts[brightness]++;
            }
            
            let entropy = 0;
            const total = pixelData.length / 4;
            for (let count of brightnessCounts) {
                if (count > 0) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
            }
            return entropy;
        }

        function calculateContrast(pixelData) {
            let min = 255, max = 0;
            for (let i = 0; i < pixelData.length; i += 4) {
                const brightness = (pixelData[i] + pixelData[i + 1] + pixelData[i + 2]) / 3;
                if (brightness < min) min = brightness;
                if (brightness > max) max = brightness;
            }
            return max - min;
        }

        function calculateMeanBrightness(pixelData) {
            let total = 0;
            for (let i = 0; i < pixelData.length; i += 4) {
                total += (pixelData[i] + pixelData[i + 1] + pixelData[i + 2]) / 3;
            }
            return total / (pixelData.length / 4);
        }

        function detectRenderingArtifacts(pixelData) {
            let artifacts = 0;
            for (let i = 0; i < pixelData.length; i += 4) {
                const r = pixelData[i], g = pixelData[i + 1], b = pixelData[i + 2];
                if (Math.abs(r - g) > 100 || Math.abs(g - b) > 100 || Math.abs(b - r) > 100) {
                    artifacts++;
                }
            }
            return artifacts / (pixelData.length / 4);
        }

        function generateAndShow() {
            const fingerprint = generateCanvasFingerprint();
            const resultDiv = document.getElementById('result');
            
            const fingerprintData = {
                device: "auto_detected_device",
                canvasFingerprint: fingerprint
            };
            
            resultDiv.innerHTML = `
                <h3>ðŸŽ¯ Your Canvas Fingerprint:</h3>
                <pre>${JSON.stringify(fingerprintData, null, 2)}</pre>
                <p><strong>Copy this data and use it in your ML system!</strong></p>
            `;
        }

        function generateAndDownload() {
            const fingerprint = generateCanvasFingerprint();
            
            const fingerprintData = {
                device: "auto_detected_device",
                canvasFingerprint: fingerprint
            };
            
            // Create download
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fingerprintData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "canvas_fingerprint.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            
            // Show result
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `
                <h3>âœ… Fingerprint Generated & Downloaded!</h3>
                <pre>${JSON.stringify(fingerprintData, null, 2)}</pre>
                <p><strong>File "canvas_fingerprint.json" has been downloaded.</strong></p>
            `;
        }

        // Auto-generate on page load and show
        window.onload = function() {
            generateAndShow();
        };
    </script>
</body>
</html>
